<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>opencl 1.0 c++ bindings: cl::Kernel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecl.html">cl</a>::<a class="el" href="classcl_1_1_kernel.html">Kernel</a>
  </div>
</div>
<div class="contents">
<h1>cl::Kernel Class Reference</h1><!-- doxytag: class="cl::Kernel" --><!-- doxytag: inherits="Wrapper&lt; cl_kernel &gt;" -->
<p><a class="el" href="classcl_1_1_kernel.html" title="Kernel interface that implements cl_kernel.">Kernel</a> interface that implements cl_kernel.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_8hpp_source.html">cl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cl::Kernel:</div>
<div class="dynsection">
 <div class="center">
  <img src="classcl_1_1_kernel.gif" usemap="#cl::Kernel_map" alt=""/>
  <map id="cl::Kernel_map" name="cl::Kernel_map">
<area href="classcl_1_1detail_1_1_wrapper.html" alt="cl::detail::Wrapper&lt; cl_kernel &gt;" shape="rect" coords="0,0,189,24"/>
</map>
 </div>
</div>

<p><a href="classcl_1_1_kernel-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a351422a7e7125812c23610628b0f9de7">Kernel</a> (const <a class="el" href="classcl_1_1_program.html">Program</a> &amp;program, const char *name, cl_int *err=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a kernel object.  <a href="#a351422a7e7125812c23610628b0f9de7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69b2fc97f80d90a23927a74395d09ec9"></a><!-- doxytag: member="cl::Kernel::Kernel" ref="a69b2fc97f80d90a23927a74395d09ec9" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a69b2fc97f80d90a23927a74395d09ec9">Kernel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor; kernel is not valid at this point. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#ad140c3e7a8796808c9380c6bf57c5d0a">getInfo</a> (cl_kernel_info name, T *param) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return information about the kernel object.  <a href="#ad140c3e7a8796808c9380c6bf57c5d0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;cl_int name&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a><br class="typebreak"/>
&lt; detail::cl_kernel_info, name &gt;<br class="typebreak"/>
::param_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a2c8ca00ff077d1bb5632d44cd0dfcae9">getInfo</a> (cl_int *err=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return information about the kernel object.  <a href="#a2c8ca00ff077d1bb5632d44cd0dfcae9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a8e6cb2e2d06d3585da1387ed7d12d2e0">getWorkGroupInfo</a> (const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;device, cl_kernel_work_group_info name, T *param) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return information about the kernel object that may be specific to a device.  <a href="#a8e6cb2e2d06d3585da1387ed7d12d2e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;cl_int name&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a><br class="typebreak"/>
&lt; detail::cl_kernel_work_group_info, <br class="typebreak"/>
name &gt;::param_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a0e0da2fe90458bf35a3c1e23ee665c3b">getWorkGroupInfo</a> (const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;device, cl_int *err=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return information about the kernel object that may be specific to a device.  <a href="#a0e0da2fe90458bf35a3c1e23ee665c3b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a0df5bb0e2c7c79f6eb5ed72df30a91c9">setArg</a> (cl_uint index, T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the argument value for a specific argument of a kernel.  <a href="#a0df5bb0e2c7c79f6eb5ed72df30a91c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#af3330fb7c6bd6459535411fb244cac38">setArg</a> (cl_uint index,::<a class="el" href="structcl_1_1size__t.html">size_t</a> size, void *argPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the argument value for a specific argument of a kernel.  <a href="#af3330fb7c6bd6459535411fb244cac38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1_kernel_functor.html">KernelFunctor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a7e50f1fa838b96a5a03b48ad960c70d6">bind</a> (const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;queue, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;offset, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;global, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;local)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind a kernel to a command-queue and launch dimensions.  <a href="#a7e50f1fa838b96a5a03b48ad960c70d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1_kernel_functor.html">KernelFunctor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_kernel.html#a89775a0ba68684180bc726cee55309d3">bind</a> (const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;queue, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;global, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;local)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind a kernel to a command-queue and launch dimensions.  <a href="#a89775a0ba68684180bc726cee55309d3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classcl_1_1_kernel.html" title="Kernel interface that implements cl_kernel.">Kernel</a> interface that implements cl_kernel. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a351422a7e7125812c23610628b0f9de7"></a><!-- doxytag: member="cl::Kernel::Kernel" ref="a351422a7e7125812c23610628b0f9de7" args="(const Program &amp;program, const char *name, cl_int *err=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl::Kernel::Kernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_program.html">Program</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a kernel object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>program</em>&nbsp;</td><td>is a program object with a successfully built executable.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a function name in the program declared with the __kernel qualifer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>will return an appropriate error code. If <em>err</em> is NULL, no error code is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid non-zero kernel object and <em>err</em> is set to CL_SUCCESS if the kernel object is created successfully. It returns a NULL value with one of the following error values returned in <em>err:</em> <ul>
<li>CL_INVALID_PROGRAM if <em>program</em> is not a valid program object</li>
<li>CL_INVALID_PROGRAM_EXECUTABLE if there is no successfully built executable for <em>program</em>.</li>
<li>CL_INVALID_KERNEL_NAME if <em>name</em> is not found in <em>program</em>.</li>
<li>CL_INVALID_KERNEL_DEFINITION if the function definition for __kernel function given by <em>name</em> such as the number of arguments, the argument types are not the same for all devices for which the program executable has been built.</li>
<li>CL_INVALID_VALUE if <em>name</em> is NULL.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a89775a0ba68684180bc726cee55309d3"></a><!-- doxytag: member="cl::Kernel::bind" ref="a89775a0ba68684180bc726cee55309d3" args="(const CommandQueue &amp;queue, const NDRange &amp;global, const NDRange &amp;local)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1_kernel_functor.html">KernelFunctor</a> cl::Kernel::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>local</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a kernel to a command-queue and launch dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>is the command-queue to bind with.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>describes the number of global work-items in will execute the kernel function. The total number of global work-items is computed as global_work_size[0] * ... * global_work_size[work_dim - 1].</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local</em>&nbsp;</td><td>describes the number of work-items that make up a work-group (also referred to as the size of the work-group) that will execute the kernel specified by kernel.</td></tr>
  </table>
  </dd>
</dl>
<p>/return A <a class="el" href="classcl_1_1_kernel_functor.html" title="Kernel functor interface.">KernelFunctor</a> object that when called with the appropriate number of arguments, as defined by kernel itself, will be launched with the corresponding queue, offset=NullRange, global, and local values. </p>

</div>
</div>
<a class="anchor" id="a7e50f1fa838b96a5a03b48ad960c70d6"></a><!-- doxytag: member="cl::Kernel::bind" ref="a7e50f1fa838b96a5a03b48ad960c70d6" args="(const CommandQueue &amp;queue, const NDRange &amp;offset, const NDRange &amp;global, const NDRange &amp;local)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1_kernel_functor.html">KernelFunctor</a> cl::Kernel::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>local</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a kernel to a command-queue and launch dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>is the command-queue to bind with.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>must currently be a NullRange value. In a future revision of OpenCL, <em>global_work_offset</em> can be used to specify an array of <em>work_dim</em> unsigned values that describe the offset used to calculate the global ID of a work-item instead of having the global IDs always start at offset (0, 0, 0).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>describes the number of global work-items in will execute the kernel function. The total number of global work-items is computed as global_work_size[0] * ... * global_work_size[work_dim - 1].</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local</em>&nbsp;</td><td>describes the number of work-items that make up a work-group (also referred to as the size of the work-group) that will execute the kernel specified by kernel.</td></tr>
  </table>
  </dd>
</dl>
<p>/return A <a class="el" href="classcl_1_1_kernel_functor.html" title="Kernel functor interface.">KernelFunctor</a> object that when called with the appropriate number of arguments, as defined by kernel itself, will be launched with the corresponding queue, offset, global, and local values. </p>

</div>
</div>
<a class="anchor" id="a2c8ca00ff077d1bb5632d44cd0dfcae9"></a><!-- doxytag: member="cl::Kernel::getInfo" ref="a2c8ca00ff077d1bb5632d44cd0dfcae9" args="(cl_int *err=NULL) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cl_int name&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a>&lt;detail::cl_kernel_info, name&gt;::param_type cl::Kernel::getInfo </td>
          <td>(</td>
          <td class="paramtype">cl_int *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return information about the kernel object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>specifies the information to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>pointer to memory location where error value will be returned. If not null, the default value, then one of the following values is returned:</p>
<ul>
<li>CL_SUCCESS if the function is executed successfully</li>
<li>CL_INVALID_VALUE if <em>name</em> is not valid.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the appropriate values for <em>name</em> will be returned.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ad140c3e7a8796808c9380c6bf57c5d0a"></a><!-- doxytag: member="cl::Kernel::getInfo" ref="ad140c3e7a8796808c9380c6bf57c5d0a" args="(cl_kernel_info name, T *param) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::Kernel::getInfo </td>
          <td>(</td>
          <td class="paramtype">cl_kernel_info&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return information about the kernel object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>specifies the information to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>is a pointer to memory where the appropriate result being queried is returned. If <em>param</em> is NULL, it is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function is executed successfully</li>
<li>CL_INVALID_VALUE if <em>param</em> is not valid.</li>
<li>CL_INVALID_KERNEL if <em>kernel</em> is a not a valid kernel object.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e0da2fe90458bf35a3c1e23ee665c3b"></a><!-- doxytag: member="cl::Kernel::getWorkGroupInfo" ref="a0e0da2fe90458bf35a3c1e23ee665c3b" args="(const Device &amp;device, cl_int *err=NULL) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cl_int name&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a>&lt;detail::cl_kernel_work_group_info, name&gt;::param_type cl::Kernel::getWorkGroupInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return information about the kernel object that may be specific to a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>specifies the information to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>pointer to memory location where error value will be returned. If not null, the default value, then one of the following values is returned:</p>
<ul>
<li>CL_SUCCESS if the function is executed successfully</li>
<li>CL_INVALID_VALUE if <em>name</em> is not valid.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the appropriate values for <em>name</em> will be returned.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e6cb2e2d06d3585da1387ed7d12d2e0"></a><!-- doxytag: member="cl::Kernel::getWorkGroupInfo" ref="a8e6cb2e2d06d3585da1387ed7d12d2e0" args="(const Device &amp;device, cl_kernel_work_group_info name, T *param) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::Kernel::getWorkGroupInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_kernel_work_group_info&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return information about the kernel object that may be specific to a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>identifies a specific device in the list of devices associated with <em>kernel</em>. The list of devices is the list of devices in the OpenCL context that is associated with <em>kernel</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>specifies the information to query</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>is a pointer to memory where the appropriate result being queried is returned. If <em>param</em> is NULL, it is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function is executed successfully,</li>
<li>CL_INVALID_DEVICE if <em>device</em> is not in the list of devices associated with <em>kernel</em>.</li>
<li>CL_INVALID_VALUE if <em>name</em> is not valid.</li>
<li>CL_INVALID_KERNEL if <em>kernel</em> is a not a valid kernel object.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="af3330fb7c6bd6459535411fb244cac38"></a><!-- doxytag: member="cl::Kernel::setArg" ref="af3330fb7c6bd6459535411fb244cac38" args="(cl_uint index,::size_t size, void *argPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::Kernel::setArg </td>
          <td>(</td>
          <td class="paramtype">cl_uint&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>argPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the argument value for a specific argument of a kernel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>is the argument index. Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n - 1, where n is the total number of arguments declared by a kernel.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is a pointer to data that should be used as the argument value for argument specified by <em>index</em>. The argument data pointed to by <em>value</em> is copied and the <em>value</em> pointer can therefore be reused by the application after setArg returns. If the argument is a memory object (buffer or image), the <em>value</em> entry will be a pointer to the appropriate buffer or image object. The memory object must be created with the context associated with the kernel object. If the argument is declared with the __local qualifier, the <em>value</em> entry must be NULL. For all other kernel arguments, the <em>value</em> entry must be a pointer to the actual data to be used as argument value. The memory object specified as argument value must be a buffer object if the argument is declared to be a pointer of a built-in or user defined type with the __global or __constant qualifier. If the argument is declared with the __constant qualifier, the size in bytes of the memory object cannot exceed CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE and the number of arguments declared with the __constant qualifier cannot exceed CL_DEVICE_MAX_CONSTANT_ARGS. The memory object specified as argument value must be a 2D image object if the argument is declared to be of type image2d_t. The memory object specified as argument value must be a 3D image object if argument is declared to be of type image3d_t. If the argument is of type sampler_t, the value entry must be a pointer to the sampler object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>specifies the size of the argument value. If the argument is a memory object, the size is the size of the buffer or image object type. For arguments declared with the __local qualifier, the size specified will be the size in bytes of the buffer that must be allocated for the __local argument. If the argument is of type sampler_t, the <em>size</em> value must be equal to sizeof(cl_sampler). For all other arguments, the size will be the size of argument type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function was executed successfully</li>
<li>CL_INVALID_ARG_INDEX if <em>index</em> is not a valid argument index.</li>
<li>CL_INVALID_ARG_VALUE if <em>value</em> specified is NULL for an argument that is not declared with the __local qualifier or vice-versa.</li>
<li>CL_INVALID_MEM_OBJECT for an argument declared to be a memory object but the specified <em>value</em> is not a valid memory object.</li>
<li>CL_INVALID_SAMPLER for an argument declared to be of type sampler_t but the specified <em>value</em> is not a valid sampler object.</li>
<li>CL_INVALID_ARG_SIZE if <em>size</em> does not match the size of the data type for an argument that is not a memory object or if the argument is a memory object and <em>size</em> != sizeof(cl_mem) or if <em>size</em> is zero and the argument is declared with the __local qualifier or if the argument is a sampler and arg_size != sizeof(cl_sampler).</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a0df5bb0e2c7c79f6eb5ed72df30a91c9"></a><!-- doxytag: member="cl::Kernel::setArg" ref="a0df5bb0e2c7c79f6eb5ed72df30a91c9" args="(cl_uint index, T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::Kernel::setArg </td>
          <td>(</td>
          <td class="paramtype">cl_uint&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the argument value for a specific argument of a kernel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>is the argument index. Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n - 1, where n is the total number of arguments declared by a kernel.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is the data to be used as the argument value for argument specified by <em>index</em>. If the argument is a memory object (buffer or image), the <em>value</em> entry will be a pointer to the appropriate buffer or image object. The memory object must be created with the context associated with the kernel object. If the argument is declared with the __local qualifier, the <em>value</em> must be a of type detail::LocalSpaceArg (use __local helper function to build a value of this type). The memory object specified as argument value must be a buffer object if the argument is declared to be a pointer of a built-in or user defined type with the __global or __constant qualifier. If the argument is declared with the __constant qualifier, the size in bytes of the memory object cannot exceed CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE and the number of arguments declared with the __constant qualifier cannot exceed CL_DEVICE_MAX_CONSTANT_ARGS. The memory object specified as argument value must be a 2D image object if the argument is declared to be of type image2d_t. The memory object specified as argument value must be a 3D image object if argument is declared to be of type image3d_t. If the argument is of type sampler_t, the value entry must be a pointer to the sampler object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function was executed successfully</li>
<li>CL_INVALID_ARG_INDEX if <em>arg_index</em> is not a valid argument index.</li>
<li>CL_INVALID_ARG_VALUE if <em>value</em> specified is of type detail::LocalSpaceArg for an argument that is not declared with the __local qualifier or vice-versa.</li>
<li>CL_INVALID_MEM_OBJECT for an argument declared to be a memory object but the specified <em>arg_value</em> is not a valid memory object.</li>
<li>CL_INVALID_SAMPLER for an argument declared to be of type sampler_t but the specified <em>arg_value</em> is not a valid sampler object.</li>
<li>CL_INVALID_ARG_SIZE if <em>argument</em> size does not match the size of the data type for an argument that is not a memory object or if the argument is a memory object and <em>arg_size</em> != sizeof(cl_mem) or if the argument is a sampler and argument size != sizeof(cl_sampler).</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/bgaster/dev/c++-api/<a class="el" href="cl_8hpp_source.html">cl.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 20 09:56:21 2009 for opencl 1.0 c++ bindings by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
