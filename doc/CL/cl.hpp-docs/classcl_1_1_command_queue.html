<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>opencl 1.0 c++ bindings: cl::CommandQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecl.html">cl</a>::<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a>
  </div>
</div>
<div class="contents">
<h1>cl::CommandQueue Class Reference</h1><!-- doxytag: class="cl::CommandQueue" --><!-- doxytag: inherits="Wrapper&lt; cl_command_queue &gt;" -->
<p><a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> interface for cl_command_queue.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_8hpp_source.html">cl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cl::CommandQueue:</div>
<div class="dynsection">
 <div class="center">
  <img src="classcl_1_1_command_queue.gif" usemap="#cl::CommandQueue_map" alt=""/>
  <map id="cl::CommandQueue_map" name="cl::CommandQueue_map">
<area href="classcl_1_1detail_1_1_wrapper.html" alt="cl::detail::Wrapper&lt; cl_command_queue &gt;" shape="rect" coords="0,0,248,24"/>
</map>
 </div>
</div>

<p><a href="classcl_1_1_command_queue-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a887826e515b03224aec87b33ac59f327">CommandQueue</a> (const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;context, const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;device, cl_command_queue_properties properties=0, cl_int *err=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a command-queue on a specific device.  <a href="#a887826e515b03224aec87b33ac59f327"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1beb7ab6e619a4e050d87c70bb001a6"></a><!-- doxytag: member="cl::CommandQueue::CommandQueue" ref="ab1beb7ab6e619a4e050d87c70bb001a6" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#ab1beb7ab6e619a4e050d87c70bb001a6">CommandQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor; command queue is not valid at this point. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#abe7aafaf5cb6d6820a0d549049aabcfd">getInfo</a> (cl_command_queue_info name, T *param) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query information about a command-queue.  <a href="#abe7aafaf5cb6d6820a0d549049aabcfd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;cl_int name&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a><br class="typebreak"/>
&lt; detail::cl_command_queue_info, <br class="typebreak"/>
name &gt;::param_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a838690886e44b54b5abb55f47c1ce7be">getInfo</a> (cl_int *err=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query information about a command-queue.  <a href="#a838690886e44b54b5abb55f47c1ce7be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#afad04c123c184d30587d9678e0593d7a">setProperty</a> (cl_command_queue_properties properties, cl_bool enable, cl_command_queue_properties *old_properties=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable the properties of a command-queue.  <a href="#afad04c123c184d30587d9678e0593d7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a52b6da3d84294a85326d834aef777988">enqueueReadBuffer</a> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking,::<a class="el" href="structcl_1_1size__t.html">size_t</a> offset,::<a class="el" href="structcl_1_1size__t.html">size_t</a> size, void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to read from a buffer object to host memory.  <a href="#a52b6da3d84294a85326d834aef777988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#adf6704674c21b4119309da78291ab0a2">enqueueWriteBuffer</a> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking,::<a class="el" href="structcl_1_1size__t.html">size_t</a> offset,::<a class="el" href="structcl_1_1size__t.html">size_t</a> size, void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to write to a buffer object from host memory.  <a href="#adf6704674c21b4119309da78291ab0a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#ad46d201111102942d77a98c9a11a631b">enqueueCopyBuffer</a> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;src, const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;dst,::<a class="el" href="structcl_1_1size__t.html">size_t</a> src_offset,::<a class="el" href="structcl_1_1size__t.html">size_t</a> dst_offset,::<a class="el" href="structcl_1_1size__t.html">size_t</a> size, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueues a command to copy a buffer object to another.  <a href="#ad46d201111102942d77a98c9a11a631b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a281669620240430a8199a7c20a521b36">enqueueReadImage</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, cl_bool blocking, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region,::<a class="el" href="structcl_1_1size__t.html">size_t</a> row_pitch,::<a class="el" href="structcl_1_1size__t.html">size_t</a> slice_pitch, void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to read from a 2D or 3D image object to host memory.  <a href="#a281669620240430a8199a7c20a521b36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#ad9f134a5ed0be521ccf2948b21b5a5c6">enqueueWriteImage</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, cl_bool blocking, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region,::<a class="el" href="structcl_1_1size__t.html">size_t</a> row_pitch,::<a class="el" href="structcl_1_1size__t.html">size_t</a> slice_pitch, void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to write to a 2D or 3D image object from host memory.  <a href="#ad9f134a5ed0be521ccf2948b21b5a5c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#aac6c3a160522dbebc8988878a40c77db">enqueueCopyImage</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;src, const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;dst, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;src_origin, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;dst_origin, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to copy image objects.  <a href="#aac6c3a160522dbebc8988878a40c77db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#ac7759aefd1073db04e20a17964249efa">enqueueCopyImageToBuffer</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;src, const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;dst, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;src_origin, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region,::<a class="el" href="structcl_1_1size__t.html">size_t</a> dst_offset, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to copy an image object to a buffer object.  <a href="#ac7759aefd1073db04e20a17964249efa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a5429fc1f7fa9c0bff9b68b4e260fc759">enqueueCopyBufferToImage</a> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;src, const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;dst,::<a class="el" href="structcl_1_1size__t.html">size_t</a> src_offset, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;dst_origin, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to copy a buffer object to an image object.  <a href="#a5429fc1f7fa9c0bff9b68b4e260fc759"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a009115a9fd42816abbffd9c2a5bef0a8">enqueueMapBuffer</a> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, cl_map_flags flags,::<a class="el" href="structcl_1_1size__t.html">size_t</a> offset,::<a class="el" href="structcl_1_1size__t.html">size_t</a> size, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL, cl_int *err=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to map a region of a buffer object into the host address.  <a href="#a009115a9fd42816abbffd9c2a5bef0a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a4733d5270ceeb8eaaba6a326d1c766cd">enqueueMapImage</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;buffer, cl_bool blocking, cl_map_flags flags, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region,::<a class="el" href="structcl_1_1size__t.html">size_t</a> *row_pitch,::<a class="el" href="structcl_1_1size__t.html">size_t</a> *slice_pitch, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL, cl_int *err=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to map a region in an image object given into the host address.  <a href="#a4733d5270ceeb8eaaba6a326d1c766cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a9e972e773a4771bd0a4a65c8585d7245">enqueueUnmapMemObject</a> (const <a class="el" href="classcl_1_1_memory.html">Memory</a> &amp;memory, void *mapped_ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to unmap a previously mapped region of a memory object.  <a href="#a9e972e773a4771bd0a4a65c8585d7245"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a0b9c89392c404d28ad6e06fbf458572e">enqueueNDRangeKernel</a> (const <a class="el" href="classcl_1_1_kernel.html">Kernel</a> &amp;kernel, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;offset, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;global, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;local, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to execute a kernel on a device.  <a href="#a0b9c89392c404d28ad6e06fbf458572e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a19f0b52a87a8a33d1280ef9e8f5149f3">enqueueTask</a> (const <a class="el" href="classcl_1_1_kernel.html">Kernel</a> &amp;kernel, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to execute a kernel on a device. The kernel is executed using a single work-item.  <a href="#a19f0b52a87a8a33d1280ef9e8f5149f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a4c64998a0b4b48a92089385559dd19d5">enqueueNativeKernel</a> (void(*userFptr)(void *), std::pair&lt; void *,::<a class="el" href="structcl_1_1size__t.html">size_t</a> &gt; args, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; const void * &gt; *mem_locs=NULL, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a command to execute a native C/C++ function not compiled using the OpenCL compiler.  <a href="#a4c64998a0b4b48a92089385559dd19d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a958649638e01340d18a1d205b79e2b50">enqueueMarker</a> (<a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a marker command.  <a href="#a958649638e01340d18a1d205b79e2b50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a0fd6a0e006a9d2c1b16c42d04448fbac">enqueueWaitForEvents</a> (const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; &amp;events) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a wait for a specific event or a list of events to complete before any future commands queued in the command-queue are executed.  <a href="#a0fd6a0e006a9d2c1b16c42d04448fbac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa17b3af26cc3d2490519076176b9f842"></a><!-- doxytag: member="cl::CommandQueue::enqueueAcquireGLObjects" ref="aa17b3af26cc3d2490519076176b9f842" args="(const VECTOR_CLASS&lt; Memory &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><b>enqueueAcquireGLObjects</b> (const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f8559a11444a036d2e70722523c49d"></a><!-- doxytag: member="cl::CommandQueue::enqueueReleaseGLObjects" ref="ac2f8559a11444a036d2e70722523c49d" args="(const VECTOR_CLASS&lt; Memory &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><b>enqueueReleaseGLObjects</b> (const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a1d32b1dd98e82680bb56f5388f1dc504">enqueueBarrier</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue a barrier operation.  <a href="#a1d32b1dd98e82680bb56f5388f1dc504"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a4349d9530f98d7544d1ddb5cbcc053bd">flush</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issue all previously queued OpenCL commands in command-queue to the device associated with command-queue.  <a href="#a4349d9530f98d7544d1ddb5cbcc053bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a49322e2223bf0c86e1485ad0ebc5de0e">finish</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block until all previously queued OpenCL runtime commands in <em>command_queue</em> are issued to the associated device and have completed.  <a href="#a49322e2223bf0c86e1485ad0ebc5de0e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> interface for cl_command_queue. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a887826e515b03224aec87b33ac59f327"></a><!-- doxytag: member="cl::CommandQueue::CommandQueue" ref="a887826e515b03224aec87b33ac59f327" args="(const Context &amp;context, const Device &amp;device, cl_command_queue_properties properties=0, cl_int *err=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl::CommandQueue::CommandQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_command_queue_properties&nbsp;</td>
          <td class="paramname"> <em>properties</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a command-queue on a specific device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>must be a valid OpenCL context.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>must be a device associated with context. It can either be in the list of devices specified when context is created using <a class="el" href="classcl_1_1_context.html" title="Context interface for cl_context.">cl::Context</a> or have the same device type as device type specified when context is created using <a class="el" href="classcl_1_1_context.html" title="Context interface for cl_context.">cl::Context</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>specifies a list of properties for the command-queue.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>will return an appropriate error code. If <em>err</em> is NULL, its default value, no error code is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid non-zero command-queue and <em>err</em> is set to CL_SUCCESS if the command-queue is created successfully or a NULL value with one of the following error values returned <em>in</em> err:<ul>
<li>CL_INVALID_CONTEXT if context is not a valid.</li>
<li>CL_INVALID_DEVICE if device is not a valid device or is not associated with context</li>
<li>CL_INVALID_VALUE if values specified in properties are not valid.</li>
<li>CL_INVALID_QUEUE_PROPERTIES if values specified in properties are valid but are not supported by the device.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1d32b1dd98e82680bb56f5388f1dc504"></a><!-- doxytag: member="cl::CommandQueue::enqueueBarrier" ref="a1d32b1dd98e82680bb56f5388f1dc504" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueBarrier </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a barrier operation. </p>
<p>The enqueueBarrier command ensures that all queued commands in command-queue have finished execution before the next batch of commands can begin execution. enqueueBarrier is a synchronization point.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function was executed successfully</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated.</dd>
<dd>
In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ad46d201111102942d77a98c9a11a631b"></a><!-- doxytag: member="cl::CommandQueue::enqueueCopyBuffer" ref="ad46d201111102942d77a98c9a11a631b" args="(const Buffer &amp;src, const Buffer &amp;dst,::size_t src_offset,::size_t dst_offset,::size_t size, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueCopyBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>src_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueues a command to copy a buffer object to another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>is the source buffer object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>is the destination buffer object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>refers to the offset where to begin reading data in <em>src</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_offset</em>&nbsp;</td><td>refers to the offset where to begin copying data in <em>dst</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>refers to the size in bytes to copy.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, then this particular command does not wait on any event to complete. The events specified in <em>event_wait_list</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular copy command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL in which case it will not be possible for the application to query the status of this command or queue and wait for this command to complete. enqueueBarrier can be used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_CONTEXT if the context associated with <em>command_queue</em>, <em>src</em> and <em>dst</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>src_buffer</em> and <em>dst_buffer</em> are not valid buffer objects.</li>
<li>CL_INVALID_VALUE if <em>src_offset</em>, <em>dst_offset</em>, <em>cb</em>, <em>src_offset</em> + <em>size</em> or <em>dst_offset</em> + <em>size</em> require accessing elements outside the buffer memory objects.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a5429fc1f7fa9c0bff9b68b4e260fc759"></a><!-- doxytag: member="cl::CommandQueue::enqueueCopyBufferToImage" ref="a5429fc1f7fa9c0bff9b68b4e260fc759" args="(const Buffer &amp;src, const Image &amp;dst,::size_t src_offset, const size_t&lt; 3 &gt; &amp;dst_origin, const size_t&lt; 3 &gt; &amp;region, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueCopyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>src_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to copy a buffer object to an image object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>is a valid buffer object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>is a valid image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>refers to the offset where to begin copying data in <em>src</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_origin</em>&nbsp;</td><td>defines the (x, y, z) offset in the image from where to copy. If <em>dst</em> is a 2D image object, the z value given by <em>dst_origin</em>[2] must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>defines the (width, height, depth) of the 2D or 3D rectangle to copy. If dst is a 2D image object, the depth value given by <em>region</em>[2] must be 1. The size in bytes of the region to be copied from <em>src</em> referred to as <em>src_cb</em> is computed as width * height * depth * bytes/image element if <em>dst</em> is a 3D image object and is computed as width * height * bytes/image element if <em>dst</em> is a 2D image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, then this particular command does not wait on any event to complete. The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular copy command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL, its default value, in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. enqueueBarrier can be used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_CONTEXT if the context associated with <em>command_queue</em>, <em>src</em> and <em>dst</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>src_buffer</em> is not a valid buffer object or <em>dst</em> is not a valid image object.</li>
<li>CL_INVALID_VALUE if the 2D or 3D rectangular region specified by <em>dst_origin</em> and <em>dst_origin</em> + <em>region</em> refers to a region outside <em>dst</em>, or if the region specified by <em>src_offset</em> and <em>src_offset</em> + <em>src_cb</em> to a region outside <em>src</em>.</li>
<li>CL_INVALID_VALUE if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="aac6c3a160522dbebc8988878a40c77db"></a><!-- doxytag: member="cl::CommandQueue::enqueueCopyImage" ref="aac6c3a160522dbebc8988878a40c77db" args="(const Image &amp;src, const Image &amp;dst, const size_t&lt; 3 &gt; &amp;src_origin, const size_t&lt; 3 &gt; &amp;dst_origin, const size_t&lt; 3 &gt; &amp;region, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueCopyImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to copy image objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>is the source image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>is the destination image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_origin</em>&nbsp;</td><td>defines the starting (x, y, z) location in <em>src</em> from where to start the data copy. If <em>src</em> is a 2D image object, the z value given by <em>src_origin</em>[2] must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_origin</em>&nbsp;</td><td>defines the starting (x, y, z) location in <em>dst</em> from where to start the data copy. If <em>dst</em> is a 2D image object, the z value given by <em>dst_origin</em>[2] must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>defines the (width, height, depth) of the 2D or 3D rectangle to copy. If <em>src</em> or <em>dst</em> is a 2D image object, the depth value given by <em>region</em>[2] must be 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, it default then this particular command does not wait on any event to complete.The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular copy command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL, its default, in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. enqueueBarrier can be used instead. It is currently a requirement that the <em>src_image</em> and <em>dst_image</em> image memory objects for enqueueCopyImage must have the exact image format (i.e. channel order and channel data type must match).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_CONTEXT if the context associated with <em>command-queue</em>, <em>src</em> and <em>dst</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>src</em> and <em>dst</em> are not valid image objects.</li>
<li>CL_IMAGE_FORMAT_MISMATCH if src and dst do not use the same image format.</li>
<li>CL_INVALID_VALUE if the 2D or 3D rectangular region specified by <em>src_origin</em> and <em>src_origin</em> + <em>region</em> refers to a region outside <em>src</em>, or if the 2D or 3D rectangular region specified by <em>dst_origin</em> and <em>dst_origin</em> + <em>region</em> refers to a region outside <em>dst</em>.</li>
<li>CL_INVALID_VALUE if <em>src</em> is a 2D image object and <em>origin</em>[2] is not equal to 0 or <em>region</em>[2] is not equal to 1.</li>
<li>CL_INVALID_VALUE if <em>dst</em> is a 2D image object and <em>dst_origin</em>[2] is not equal to 0 or <em>region</em>[2] is not equal to 1.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7759aefd1073db04e20a17964249efa"></a><!-- doxytag: member="cl::CommandQueue::enqueueCopyImageToBuffer" ref="ac7759aefd1073db04e20a17964249efa" args="(const Image &amp;src, const Buffer &amp;dst, const size_t&lt; 3 &gt; &amp;src_origin, const size_t&lt; 3 &gt; &amp;region,::size_t dst_offset, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueCopyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to copy an image object to a buffer object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>is a valid image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>is a valid buffer object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_origin</em>&nbsp;</td><td>defines the (x, y, z) offset in the image from where to copy. If <em>src</em> is a 2D image object, the z value given by <em>src_origin</em>[2] must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>defines the (width, height, depth) of the 2D or 3D rectangle to copy. If <em>src_image</em> is a 2D image object, the depth value given by <em>region</em>[2] must be 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>refers to the offset where to begin copying data in <em>dst</em>. The size in bytes of the region to be copied referred to as <em>dst_cb</em> is computed as width * height * depth * bytes/image element if <em>src</em> is a 3D image object and is computed as width * height * bytes/image element if <em>src</em> is a 2D image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, it default then this particular command does not wait on any event to complete.The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular copy command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL, its default value, in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. enqueueBarrier can be used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_CONTEXT if the context associated with <em>command-queue</em>, <em>src</em> and <em>dst_buffer</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>src_image</em> is not a valid image object or <em>dst</em> is not a valid buffer object.</li>
<li>CL_INVALID_VALUE if the 2D or 3D rectangular region specified by <em>src_origin</em> and <em>src_origin</em> + <em>region</em> refers to a region outside <em>src</em>, or if the region specified by <em>dst_offset</em> and <em>dst_offset</em> + <em>dst_cb</em> to a region outside <em>dst</em>.</li>
<li>CL_INVALID_VALUE if <em>src</em> is a 2D image object and <em>src_origin</em>[2] is not equal to 0 or <em>region</em>[2] is not equal to 1.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a009115a9fd42816abbffd9c2a5bef0a8"></a><!-- doxytag: member="cl::CommandQueue::enqueueMapBuffer" ref="a009115a9fd42816abbffd9c2a5bef0a8" args="(const Buffer &amp;buffer, cl_bool blocking, cl_map_flags flags,::size_t offset,::size_t size, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL, cl_int *err=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cl::CommandQueue::enqueueMapBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&nbsp;</td>
          <td class="paramname"> <em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_map_flags&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to map a region of a buffer object into the host address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&nbsp;</td><td>indicates if the map operation is blocking or non-blocking. If <em>blocking</em> is CL_TRUE, enqueueMapBuffer does not return until the specified region in <em>buffer</em> can be mapped. If <em>blocking</em> is CL_FALSE i.e. map operation is non-blocking, the pointer to the mapped region returned by enqueueMapBuffer cannot be used until the map command has completed. The event argument returns an event object which can be used to query the execution status of the map command. When the map command is completed, the application can access the contents of the mapped region using the pointer returned by enqueueMapBuffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>map_flags</em>&nbsp;</td><td>is a bit-field and can be set to CL_MAP_READ to indicate that the region specified by (<em>offset</em>, <em>size</em>) in the buffer object is being mapped for reading, and/or CL_MAP_WRITE to indicate that the region specified by (<em>offset</em>, <em>size</em>) in the buffer object is being mapped for writing.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>is a valid buffer object. The OpenCL context associated with <em>command-queue</em> and <em>buffer</em> must be the same.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>is the offset in bytes of the region in the buffer object that is being mapped</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the size in bytes of the region in the buffer object that is being mapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, its default value, then this particular command does not wait on any event to complete. The events specified in <em>event_wait_list</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. enqueueBarrier can be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>will return an appropriate error code. If <em>err</em> is NULL, its default value, no error code is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the mapped region if buffer is a memory object created with clCreateBuffer and the region specified by (offset , cb) is a valid region in the buffer object and is successfully mapped into the host address space . The <em>errcode_ret</em> is set to CL_SUCCESS. A NULL pointer is returned otherwise with one of the following error values returned in <em>errcode_ret:</em> <ul>
<li>CL_INVALID_CONTEXT if context associated with <em>command-queue</em> and <em>buffer</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>buffer</em> is not a valid buffer object.</li>
<li>CL_INVALID_VALUE if region being mapped given by (<em>offset</em>, <em>size</em>) is out of bounds or if values specified in <em>map_flags</em> are not valid.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_MEM_O BJECT_MAP_FAILURE if there is a failure to map the specified region in the host address space.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<p>The pointer returned maps a region starting at <em>offset</em> and is at least <em>size</em> bytes in size. The result of a memory access outside this region is undefined.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a4733d5270ceeb8eaaba6a326d1c766cd"></a><!-- doxytag: member="cl::CommandQueue::enqueueMapImage" ref="a4733d5270ceeb8eaaba6a326d1c766cd" args="(const Image &amp;buffer, cl_bool blocking, cl_map_flags flags, const size_t&lt; 3 &gt; &amp;origin, const size_t&lt; 3 &gt; &amp;region,::size_t *row_pitch,::size_t *slice_pitch, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL, cl_int *err=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cl::CommandQueue::enqueueMapImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&nbsp;</td>
          <td class="paramname"> <em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_map_flags&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a> *&nbsp;</td>
          <td class="paramname"> <em>row_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a> *&nbsp;</td>
          <td class="paramname"> <em>slice_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_int *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to map a region in an image object given into the host address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>is a valid image object. The OpenCL context associated with the command-queue and <em>image</em> must be the same.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&nbsp;</td><td>indicates if the map operation is blocking or non-blocking. If <em>blocking</em> is CL_TRUE, enqueueMapImage does not return until the specified region in image is mapped. If <em>blocking</em> is CL_FALSE i.e. map operation is non-blocking, the pointer to the mapped region returned by enqueueMapImage cannot be used until the map command has completed. The event argument returns an event object which can be used to query the execution status of the map command. When the map command is completed, the application can access the contents of the mapped region using the pointer returned by enqueueMapImage.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>is a bit-field and can be set to CL_MAP_READ to indicate that the region specified by (<em>origin</em>, <em>region</em>) in the image object is being mapped for reading, and/or CL_MAP_WRITE to indicate that the region specified by (<em>origin</em>, <em>region</em>) in the image object is being mapped for writing.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>define the (x, y, z) offset of the 2D or 3D rectangle region that is to be mapped. If image is a 2D image object, the z value given by <em>origin</em>[2] must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>define the (width, height, depth) of the 2D or 3D rectangle region that is to be mapped. If image is a 2D image object, the depth value given by <em>region</em>[2] must be 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>row_pitch</em>&nbsp;</td><td>returns the scan-line pitch in bytes for the mapped region. This must be a non- NULL value.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slice_pitch</em>&nbsp;</td><td>returns the size in bytes of each 2D slice for the mapped region. For a 2D image this argument is ignored. For a 3D image this must be a non-NULL value.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before enqueueMapImage can be executed. If <em>events</em> is NULL, then enqueueMapImage does not wait on any event to complete. The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL, its default value, in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. enqueueBarrier can be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>will return an appropriate error code. If <em>err</em> is NULL, its default value, o error code is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the mapped region if image is a memory object created with clCreateImage {2D|3D}, and the 2D or 3D rectangle specified by origin and region is a valid region in the image object and can be mapped into the host address space. The <em>err</em> is set to CL_SUCCESS. A NULL pointer is returned otherwise with one of the following error values returned in <em>err:</em> <ul>
<li>CL_INVALID_CONTEXT if context associated with <em>command_queue</em> and <em>image</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>image</em> is not a valid image object.</li>
<li>CL_INVALID_VALUE if region being mapped given by (<em>origin</em>, <em>origin</em> + <em>region</em>) is out of bounds or if values specified in <em>map_flags</em> are not valid.</li>
<li>CL_INVALID_VALUE if <em>image</em> is a 2D image object and <em>origin</em>[2] is not equal to 0 or <em>region</em>[2] is not equal to 1.</li>
<li>CL_INVALID_VALUE if <em>row_pitch</em> is NULL.</li>
<li>CL_INVALID_VALUE if <em>image</em> is a 3D image object and <em>slice_pitch</em> is NULL.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_MEM_OBJECT_MAP_FAILURE if there is a failure to map the specified region in the host address space.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<p>The pointer returned maps a 2D or 3D region starting at origin and is at least (<em>row_pitch</em> * <em>region</em>[1] + <em>region</em>[0]) pixels in size for a 2D image, and is at least (<em>slice_pitch</em> * <em>region</em>[2] + <em>row_pitch</em> * <em>region</em>[1] + <em>region</em>[0]) pixels in size for a 3D image. The result of a memory access outside this region is undefined.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a958649638e01340d18a1d205b79e2b50"></a><!-- doxytag: member="cl::CommandQueue::enqueueMarker" ref="a958649638e01340d18a1d205b79e2b50" args="(Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a marker command. </p>
<p>The marker command returns an event which can be used to queue a wait on this marker event i.e. wait for all commands queued before the marker command to complete.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function is successfully executed</li>
<li>CL_INVALID_VALUE if <em>event</em> is a NULL value</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c64998a0b4b48a92089385559dd19d5"></a><!-- doxytag: member="cl::CommandQueue::enqueueNativeKernel" ref="a4c64998a0b4b48a92089385559dd19d5" args="(void(*userFptr)(void *), std::pair&lt; void *,::size_t &gt; args, const VECTOR_CLASS&lt; Memory &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; const void * &gt; *mem_locs=NULL, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueNativeKernel </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>userFptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; void *,::<a class="el" href="structcl_1_1size__t.html">size_t</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>mem_objects</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; const void * &gt; *&nbsp;</td>
          <td class="paramname"> <em>mem_locs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to execute a native C/C++ function not compiled using the OpenCL compiler. </p>
<p>A native user function can only be executed on a command-queue created on a device that has CL_EXEC_NATIVE_KERNEL capability set in CL_DEVICE_EXECUTION_CAPABILITIES.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>userFptr</em>&nbsp;</td><td>is a pointer to a host-callable user function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>a pair containing a a pointer to the args list that <em>user_func</em> should be called with and the size in bytes of the args list that args points to. Size number of bytes of the data pointed to by args will be copied and a pointer to this copied region will be passed to <em>userFptr</em>. The copy needs to be done because the memory objects (cl_mem values) that args may contain need to be modified and replaced by appropriate pointers to global memory. When clEnqueueNativeKernel returns, the memory region pointed to by args can be reused by the application.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mem_objects</em>&nbsp;</td><td>is a list of valid memory objects, whose size &gt; 0 implies that each element is a pointer to appropriate locations that args points to where memory object handles (cl_mem values) are stored. Before the user function is executed, the memory object handles are replaced by pointers to global memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>as described in enqueueNDRangeKernel.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event objects that identifies this particular kernel execution instance. <a class="el" href="classcl_1_1_event.html" title="Event interface for cl_event.">Event</a> objects are unique and can be used to identify a particular kernel execution instance later on. If <em>event</em> is NULL, its default, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the user function execution instance was successfully queued</li>
<li>CL_INVALID_VALUE if <em>user_func</em> is NULL.</li>
<li>CL_INVALID_OPERATION if device cannot execute the native kernel.</li>
<li>CL_INVALID_MEM_OBJECT if one or more memory objects specified in <em>mem_list</em> are not valid or are not buffer objects.</li>
<li>CL_OUT_OF_RESOURCES if there is a failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel.</li>
<li>CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to allocate memory for buffer objects specified as arguments to <em>kernel</em>.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b9c89392c404d28ad6e06fbf458572e"></a><!-- doxytag: member="cl::CommandQueue::enqueueNDRangeKernel" ref="a0b9c89392c404d28ad6e06fbf458572e" args="(const Kernel &amp;kernel, const NDRange &amp;offset, const NDRange &amp;global, const NDRange &amp;local, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueNDRangeKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_kernel.html">Kernel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to execute a kernel on a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>is a valid kernel object. The OpenCL context associated with <em>kernel</em> and <em>command-queue</em> must be the same.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>must currently be a NullRange value. In a future revision of OpenCL, <em>global_work_offset</em> can be used to specify an array of <em>work_dim</em> unsigned values that describe the offset used to calculate the global ID of a work-item instead of having the global IDs always start at offset (0, 0, 0).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>describes the number of global work-items in will execute the kernel function. The total number of global work-items is computed as global_work_size[0] * ... * global_work_size[work_dim - 1].</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local</em>&nbsp;</td><td>describes the number of work-items that make up a work-group (also referred to as the size of the work-group) that will execute the kernel specified by kernel.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, its default, or size zero then this particular command does not wait on any event to complete. The events specified in <em>event_wait_list</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular kernel execution instance. <a class="el" href="classcl_1_1_event.html" title="Event interface for cl_event.">Event</a> objects are unique and can be used to identify a particular kernel execution instance later on. If <em>event</em> is NULL, its default value, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance.</td></tr>
  </table>
  </dd>
</dl>
<p>The total number of work-items in a work-group is computed as local_work_size[0] * ... * local_work_size[work_dim - 1]. The total number of work-items in the work-group must be less than or equal to the CL_DEVICE_MAX_WORK_GROUP_SIZE. The explicitly specified <em>local_work_size</em> will be used to determine how to break the global work-items specified by global_work_size into appropriate work-group instances. If <em>local_work_size</em> is specified, the values specified in <em>global_work_size</em>[0], ..., global_work_size[work_dim - 1] must be evenly divisable by the corresponding values specified in <em>local_work_size</em>[0],..., local_work_size[work_dim - 1]. <em>local_work_size</em> can also be a NULL value in which case the OpenCL implementation will determine how to be break the global work-items into appropriate work-groups.</p>
<p>If <em>local</em> is NullRange and no work-group size is specified when the kernel is compiled, the OpenCL implementation will determine how to break the global work-items specified by <em>global</em> into appropriate work-group instances. The work-group size to be used for kernel can also be specified in the program source using the __attribute__((reqd_work_group_size(X, Y, Z))) qualifier. In this case the size of work group specified by <em>local_work_size</em> must match the value specified by the <em>reqd_work_group_size</em> attribute qualifier.</p>
<p>These work-group instances are executed in parallel across multiple compute units or concurrently on the same compute unit. Each work-item is uniquely identified by a global identifier. The global ID, which can be read inside the kernel is computed using the value given by <em>global_work_size</em> and <em>global_work_offset</em>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:</dd></dl>
<ul>
<li>CL_SUCCESS if the kernel execution was successfully queued.</li>
<li>CL_INVALID_PROGRAM_EXECUTABLE if there is no successfully built program executable available for device associated with command-queue.</li>
<li>CL_INVALID_COMMAND_QUEUE if command-queue is not a valid command-queue.</li>
<li>CL_INVALID_KERNEL if <em>kernel</em> is not a valid kernel object.</li>
<li>CL_INVALID_KERNEL_ARGS if the kernel argument values have not been specified or are not valid for the device on which kernel will be executed.</li>
<li>CL_INVALID_WORK_DIMENSION if <em>work_dim</em> is not a valid value (i.e. a value between 1 and 3).</li>
</ul>
<ul>
<li>CL_INVALID_WORK_GROUP_SIZE if <em>local</em> is specified and number of workitems specified by <em>global</em> is not evenly divisable by size of work-given by <em>local_work_size</em> or does not match the work-group size specified for kernel using the __attribute__((reqd_work_group_size(X, Y, Z))) qualifier in program source.</li>
</ul>
<ul>
<li>CL_INVALID_GLOBAL_OFFSET if <em>offset</em> is not NullRange.</li>
</ul>
<ul>
<li>CL_OUT_OF_RESOURCES if there is a failure to queue the execution instance of <em>kernel</em> on the command-queue because of insufficient resources needed to execute the kernel. For example, the explicitly specified <em>local_work_dim</em> in range causes a failure to execute the kernel because of insufficient resources such as registers or local memory. Another example would be the number of read-only image args used in kernel exceed the CL_DEVICE_MAX_READ_IMAGE_ARGS value for device or the number of write-only image args used in kernel exceed the CL_DEVICE_MAX_WRITE_IMAGE_ARGS value for device or the number of samplers used in kernel exceed CL_DEVICE_MAX_SAMPLERS for device.</li>
</ul>
<ul>
<li>CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to allocate memory for image or buffer objects specified as arguments to kernel.</li>
</ul>
<ul>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a52b6da3d84294a85326d834aef777988"></a><!-- doxytag: member="cl::CommandQueue::enqueueReadBuffer" ref="a52b6da3d84294a85326d834aef777988" args="(const Buffer &amp;buffer, cl_bool blocking,::size_t offset,::size_t size, void *ptr, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueReadBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&nbsp;</td>
          <td class="paramname"> <em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to read from a buffer object to host memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>refers to a valid buffer object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&nbsp;</td><td>indicates if the read operation is blocking or nonblocking. If <em>blocking</em> is CL_TRUE i.e. the read command is blocking, enqueueReadBuffer does not return until the buffer data has been read and copied into memory pointed to by ptr. If <em>blocking</em> is CL_FALSE i.e. the read command is non-blocking, enqueueReadBuffer queues a non-blocking read command and returns. The contents of the buffer that ptr points to cannot be used until the read command has completed. The <em>event</em> argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that ptr points to can be used by the application.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>is the offset in bytes in the buffer object to read from or write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>is the size in bytes of data being read or written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>is the pointer to buffer in host memory where data is to be read into or to be written from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, its default, then this particular command does not wait on any event to complete. The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL, its default, in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_CONTEXT if the context associated with <em>command_queue</em> and <em>buffer</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>buffer</em> is not a valid buffer object.</li>
<li>CL_INVALID_VALUE if the region being read or written specified by (offset, size) is out of bounds or if <em>ptr</em> is a NULL value.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a281669620240430a8199a7c20a521b36"></a><!-- doxytag: member="cl::CommandQueue::enqueueReadImage" ref="a281669620240430a8199a7c20a521b36" args="(const Image &amp;image, cl_bool blocking, const size_t&lt; 3 &gt; &amp;origin, const size_t&lt; 3 &gt; &amp;region,::size_t row_pitch,::size_t slice_pitch, void *ptr, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueReadImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&nbsp;</td>
          <td class="paramname"> <em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>row_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>slice_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to read from a 2D or 3D image object to host memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>refers to a valid 2D or 3D image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&nbsp;</td><td>indicates if the read is blocking or nonblocking. If <em>blocking</em> is CL_TRUE i.e. the read command is blocking, enqueueReadImage does not return until the buffer data has been read and copied into memory pointed to by <em>ptr</em>. If <em>blocking</em> is CL_FALSE i.e. the read command is non-blocking, enqueueReadImage queues a non-blocking read command and returns. The contents of the buffer that <em>ptr</em> points to cannot be used until the read command has completed. The <em>event</em> argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that ptr points to can be used by the application</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>defines the (x, y, z) offset in the image from where to read or write. If image is a 2D image object, the z value given by origin[2] must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>defines the (width, height, depth) of the 2D or 3D rectangle being read or written. If image is a 2D image object, the depth value given by region[2] must be 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>row_pitch</em>&nbsp;</td><td>in enqueueReadImage is the length of each row in bytes. This value must be greater than or equal to the element size in bytes width. If <em>row_pitch</em> is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slice_pitch</em>&nbsp;</td><td>in enqueueReadImage is the size in bytes of the 2D slice of the 3D region of a 3D image being read or written respectively. This must be 0 if image is a 2D image. This value must be greater than or equal to row_pitch * height. If <em>slice_pitch</em> is set to 0, the appropriate slice pitch is calculated based on the <em>row_pitch</em> * <em>height</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>is the pointer to a buffer in host memory where image data is to be read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, it default then this particular command does not wait on any event to complete.The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_CONTEXT if the context associated with <em>command_queue</em> and <em>image</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>image</em> is not a valid image object.</li>
<li>CL_INVALID_VALUE if the region being read specified by <em>origin</em> and <em>region</em> is out of bounds or if <em>ptr</em> is a NULL value.</li>
<li>CL_INVALID_VALUE if <em>image</em> is a 2D image object and <em>origin</em>[2] is not equal to 0 or <em>region</em>[2] is not equal to 1 or <em>slice_pitch</em> is not equal to 0.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_INVALID_VALUE if blocking is CL_FALSE and <em>event</em> is NULL.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a19f0b52a87a8a33d1280ef9e8f5149f3"></a><!-- doxytag: member="cl::CommandQueue::enqueueTask" ref="a19f0b52a87a8a33d1280ef9e8f5149f3" args="(const Kernel &amp;kernel, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_kernel.html">Kernel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to execute a kernel on a device. The kernel is executed using a single work-item. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>is a valid kernel object. The OpenCL context associated with <em>kernel</em> and <em>command-queue</em> must be the same.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies the list of events that need to complete before this particular command can be executed. If <em>events</em> is NULL, its default value, then this particular command does not wait on any event to complete. The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular kernel execution instance. <a class="el" href="classcl_1_1_event.html" title="Event interface for cl_event.">Event</a> objects are unique and can be used to identify a particular kernel execution instance later on. If <em>event</em> is NULL, its default value, no event will be created for this kernel execution instance and therefore it will not be possible for the application to query or queue a wait for this particular kernel execution instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the kernel execution was successfully queued.</li>
<li>CL_INVALID_PROGRAM_EXECUTABLE if there is no successfully built program executable available for device associated with command-queue.</li>
<li>CL_INVALID_KERNEL if <em>kernel</em> is not a valid kernel object.</li>
<li>CL_INVALID_KERNEL_ARGS if the kernel argument values have not been specified or are not valid for the device on which kernel will be executed.</li>
<li>CL_INVALID_WORK_GROUP_SIZE if a work-group size is specified for kernel using the __attribute__((reqd_work_group_size(X, Y, Z))) qualifier in program source and is not (1, 1, 1).</li>
<li>CL_OUT_OF_RESOURCES if there is a failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel. For example, the explicitly specified <em>local_work_dim</em> in range causes a failure to execute the kernel because of insufficient resources such as registers or local memory. Another example would be the number of read-only image args used in kernel exceed the CL_DEVICE_MAX_READ_IMAGE_ARGS value for device or the number of write-only image args used in kernel exceed the CL_DEVICE_MAX_WRITE_IMAGE_ARGS value for device or the number of samplers used in kernel exceed CL_DEVICE_MAX_SAMPLERS for device.</li>
<li>CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to allocate memory for image or buffer objects specified as arguments to kernel.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e972e773a4771bd0a4a65c8585d7245"></a><!-- doxytag: member="cl::CommandQueue::enqueueUnmapMemObject" ref="a9e972e773a4771bd0a4a65c8585d7245" args="(const Memory &amp;memory, void *mapped_ptr, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueUnmapMemObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_memory.html">Memory</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mapped_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to unmap a previously mapped region of a memory object. </p>
<p>Reads or writes from the host using the pointer returned by enqueueMapBuffer or enqueueMapImage are considered to be complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memobj</em>&nbsp;</td><td>is a valid memory object. The OpenCL context associated with the command-queue and <em>memobj</em> must be the same.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mapped_ptr</em>&nbsp;</td><td>is the host address returned by a previous call to enqueueMapBuffer or enqueueMapImage for <em>memobj</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before enqueueUnmapMemObject can be executed. If <em>events</em> is NULL, then enqueueUnmapMemObject does not wait on any event to complete. The events specified in <em>event_wait_list</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL, its default value, in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete. enqueueBarrier can be used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function is executed successfully.</li>
<li>CL_INVALID_MEM_OBJECT if <em>memobj</em> is not a valid memory object.</li>
<li>CL_INVALID_VALUE if <em>mapped_ptr</em> is not a valid pointer returned by enqueueMapBuffer or enqueueMapImage for <em>memobj</em>.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
<li>CL_INVALID_CONTEXT if context associated with the command-queue and <em>memobj</em> are not the same.</li>
</ul>
</dd></dl>
<p>enqueueMapBuffer and enqueueMapImage increments the mapped count of the memory object. Multiple calls to enqueueMapBuffer or enqueueMapImage on the same memory object will increment this mapped count by appropriate number of calls. enqueueUnmapMemObject decrements the mapped count of the memory object. enqueueMapBuffer and enqueueMapImage act as synchronization points for a region of the memory object being mapped.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fd6a0e006a9d2c1b16c42d04448fbac"></a><!-- doxytag: member="cl::CommandQueue::enqueueWaitForEvents" ref="a0fd6a0e006a9d2c1b16c42d04448fbac" args="(const VECTOR_CLASS&lt; Event &gt; &amp;events) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueWaitForEvents </td>
          <td>(</td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>events</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a wait for a specific event or a list of events to complete before any future commands queued in the command-queue are executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>is the list of events. Each event in <em>events</em> must be a valid event object returned by a previous call to:</p>
<ul>
<li>enqueueNDRangeKernel</li>
<li>enqueueTask</li>
<li>enqueueNativeKernel</li>
<li>enqueue{Read|Write|Map}{Buffer|Image}</li>
<li>enqueueCopy{Buffer|Image}</li>
<li>enqueueCopyBufferToImage</li>
<li>enqueueCopyImageToBuffer</li>
<li>enqueueMarker. The events specified in <em>event_list</em> act as synchronization points.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function was successfully executed.</li>
<li>CL_INVALID_VALUE if size of <em>events</em> is zero</li>
<li>CL_INVALID_EVENT if event objects specified in <em>events</em> are not valid events</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="adf6704674c21b4119309da78291ab0a2"></a><!-- doxytag: member="cl::CommandQueue::enqueueWriteBuffer" ref="adf6704674c21b4119309da78291ab0a2" args="(const Buffer &amp;buffer, cl_bool blocking,::size_t offset,::size_t size, void *ptr, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueWriteBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&nbsp;</td>
          <td class="paramname"> <em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to write to a buffer object from host memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>refers to a valid buffer object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&nbsp;</td><td>indicates if the write operation is blocking or non-blocking. If <em>blocking</em> is CL_TRUE, the OpenCL implementation copies the data referred to by <em>ptr</em> and enqueues the write operation in the command-queue. The memory pointed to by <em>ptr</em> can be reused by the application after the enqueueWriteBuffer call returns. If <em>blocking</em> is CL_FALSE, the OpenCL implementation will use <em>ptr</em> to perform a nonblocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by <em>ptr</em> cannot be reused by the application after the call returns. The <em>event</em> argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by <em>ptr</em> can then be reused by the application</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>is the offset in bytes in the buffer object to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>is the size in bytes of data being read or written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>is the pointer to buffer in host memory where data is to be read into or to be written from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, its default, then this particular command does not wait on any event to complete. The events specified in <em>event_wait_list</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular write command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_MEM_OBJECT if <em>buffer</em> is not a valid buffer object.</li>
<li>CL_INVALID_VALUE if the region being read or written specified by (offset, size) is out of bounds or if <em>ptr</em> is a NULL value.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f134a5ed0be521ccf2948b21b5a5c6"></a><!-- doxytag: member="cl::CommandQueue::enqueueWriteImage" ref="ad9f134a5ed0be521ccf2948b21b5a5c6" args="(const Image &amp;image, cl_bool blocking, const size_t&lt; 3 &gt; &amp;origin, const size_t&lt; 3 &gt; &amp;region,::size_t row_pitch,::size_t slice_pitch, void *ptr, const VECTOR_CLASS&lt; Event &gt; *events=NULL, Event *event=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueWriteImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&nbsp;</td>
          <td class="paramname"> <em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>row_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structcl_1_1size__t.html">size_t</a>&nbsp;</td>
          <td class="paramname"> <em>slice_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue a command to write to a 2D or 3D image object from host memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>refers to a valid 2D or 3D image object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocking</em>&nbsp;</td><td>indicates if the write operation is blocking or nonblocking. If blocking is CL_TRUE, the OpenCL implementation copies the data referred to by <em>ptr</em> and enqueues the write command in the command-queue. The memory pointed to by ptr can be reused by the application after the enqueueWriteImage call returns. If blocking is CL_FALSE, the OpenCL implementation will use ptr to perform a nonblocking write. As the write is non-blocking the implementation can return immediately. The memory pointed to by ptr cannot be reused by the application after the call returns. The event argument returns an event object which can be used to query the execution status of the write command. When the write command has completed, the memory pointed to by ptr can then be reused by the application.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>defines the (x, y, z) offset in the image from where to read or write. If image is a 2D image object, the z value given by origin[2] must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>defines the (width, height, depth) of the 2D or 3D rectangle being read or written. If image is a 2D image object, the depth value given by region[2] must be 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_row_pitch</em>&nbsp;</td><td>in is the length of each row in bytes. This value must be greater than or equal to the element size in bytes width. If <em>input_row_pitch</em> is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_slice_pitch</em>&nbsp;</td><td>is the size in bytes of the 2D slice of the 3D region of a 3D image being read or written respectively. This must be 0 if image is a 2D image. This value must be greater than or equal to input_row_pitch * height. If <em>input_slice_pitch</em> is set to 0, the appropriate slice pitch is calculated based on the <em>input_row_pitch</em> * <em>height</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>is the pointer to a buffer in host memory where image data is to be written to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>specifies events that need to complete before this particular command can be executed. If <em>events</em> is NULL, it default then this particular command does not wait on any event to complete.The events specified in <em>events</em> act as synchronization points.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete. <em>event</em> can be NULL in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SUCCESS if the function is executed successfully. Otherwise it returns one of the following errors:<ul>
<li>CL_INVALID_CONTEXT if the context associated with <em>command_queue</em> and <em>image</em> are not the same.</li>
<li>CL_INVALID_MEM_OBJECT if <em>image</em> is not a valid image object.</li>
<li>CL_INVALID_VALUE if the region being written specified by <em>origin</em> and <em>region</em> is out of bounds or if <em>ptr</em> is a NULL value.</li>
<li>CL_INVALID_VALUE if <em>image</em> is a 2D image object and <em>origin</em>[2] is not equal to 0 or <em>region</em>[2] is not equal to 1 or <em>slice_pitch</em> is not equal to 0.</li>
<li>CL_INVALID_EVENT_WAIT_LIST if event objects in <em>events</em> are not valid events.</li>
<li>CL_INVALID_VALUE if blocking is CL_FALSE and <em>event</em> is NULL.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a49322e2223bf0c86e1485ad0ebc5de0e"></a><!-- doxytag: member="cl::CommandQueue::finish" ref="a49322e2223bf0c86e1485ad0ebc5de0e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::finish </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block until all previously queued OpenCL runtime commands in <em>command_queue</em> are issued to the associated device and have completed. </p>
<p>finish does not return until all queued commands in <em>command_queue</em> have been processed and completed. finish is also a synchronization point.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function call was executed successfully.</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a4349d9530f98d7544d1ddb5cbcc053bd"></a><!-- doxytag: member="cl::CommandQueue::flush" ref="a4349d9530f98d7544d1ddb5cbcc053bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::flush </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Issue all previously queued OpenCL commands in command-queue to the device associated with command-queue. </p>
<p>flush only guarantees that all queued commands get issued to the appropriate device. There is no guarantee that they will be complete after flush returns.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function call was executed successfully</li>
<li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the runtime.</li>
</ul>
</dd></dl>
<p>Any blocking commands queued in a command-queue such as enqueueRead{Image|Buffer} with <em>blocking_read</em> set to CL_TRUE, s enqueueWrite{Image|Buffer} with <em>blocking_write</em> set to CL_TRUE, enqueueMap{Buffer|Image} with <em>blocking_map</em> set to CL_TRUE or waitForEvents perform an implicit flush of the command-queue.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a838690886e44b54b5abb55f47c1ce7be"></a><!-- doxytag: member="cl::CommandQueue::getInfo" ref="a838690886e44b54b5abb55f47c1ce7be" args="(cl_int *err=NULL) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cl_int name&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a>&lt;detail::cl_command_queue_info, name&gt;::param_type cl::CommandQueue::getInfo </td>
          <td>(</td>
          <td class="paramtype">cl_int *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query information about a command-queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>specifies the information to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>pointer to memory location where error value will be returned. If not null, the default value, then one of the following values is returned:</p>
<ul>
<li>CL_SUCCESS if the function is executed successfully</li>
<li>CL_INVALID_VALUE if <em>name</em> is not valid.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the appropriate values for <em>name</em> will be returned.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="abe7aafaf5cb6d6820a0d549049aabcfd"></a><!-- doxytag: member="cl::CommandQueue::getInfo" ref="abe7aafaf5cb6d6820a0d549049aabcfd" args="(cl_command_queue_info name, T *param) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::getInfo </td>
          <td>(</td>
          <td class="paramtype">cl_command_queue_info&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query information about a command-queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>specifies the information to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>is a pointer to memory where the appropriate result being queried is returned. If <em>param_value</em> is NULL, it is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the function is executed successfully.</li>
<li>CL_INVALID_VALUE if <em>name</em> is not one of the supported values.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="afad04c123c184d30587d9678e0593d7a"></a><!-- doxytag: member="cl::CommandQueue::setProperty" ref="afad04c123c184d30587d9678e0593d7a" args="(cl_command_queue_properties properties, cl_bool enable, cl_command_queue_properties *old_properties=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::setProperty </td>
          <td>(</td>
          <td class="paramtype">cl_command_queue_properties&nbsp;</td>
          <td class="paramname"> <em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_command_queue_properties *&nbsp;</td>
          <td class="paramname"> <em>old_properties</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable the properties of a command-queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>specifies the new command-queue properties to be applied to <em>command_queue</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>determines whether the values specified by properties are enabled (if enable is CL_TRUE) or disabled (if enable is CL_FALSE) for the command-queue .</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_properties</em>&nbsp;</td><td>returns the command-queue properties before they were changed by setProperty. If <em>old_properties</em> is NULL, its default, it is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the following values:<ul>
<li>CL_SUCCESS if the command-queue properties are successfully updated.</li>
<li>CL_INVALID_VALUE if the values specified in properties are not valid.</li>
<li>CL_INVALID_QUEUE_PROPERTIES if values specified in properties are not supported by the device.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In the case that exceptions are enabled and error value other than CL_SUCCESS is generated, then cl::Error exception is generated. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/bgaster/dev/c++-api/<a class="el" href="cl_8hpp_source.html">cl.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 20 09:56:21 2009 for opencl 1.0 c++ bindings by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
