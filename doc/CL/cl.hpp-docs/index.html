<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>opencl 1.0 c++ bindings: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>opencl 1.0 c++ bindings Documentation</h1><h2><a class="anchor" id="intro">
Introduction</a></h2>
<p>For many large applications C++ is the language of choice and so it seems reasonable to define C++ bindings for OpenCL.</p>
<p>This document describes C++ binding interface for OpenCL 1.0 (rev 45).</p>
<p>The interface is contained with a single C++ header file <em><a class="el" href="cl_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 45).">cl.hpp</a></em> and all definitions are contained within the namespace <em><a class="el" href="namespacecl.html" title="The OpenCL C++ bindings are defined within this namespace.">cl</a></em>. There is no additional requirement to include <em>cl.h</em> and to use either the C++ or original C bindings it is enough to simply include <em><a class="el" href="cl_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 45).">cl.hpp</a></em>.</p>
<p>The bindings themselves are lightweight and correspond closely to the underlying C API. Using the C++ bindings introduces no additional execution overhead.</p>
<h2><a class="anchor" id="example">
Example</a></h2>
<p>The following example shows a general use case for the C++ bindings, including support for the optional exception feature and also the supplied vector and string classes, see following sections for decriptions of these features.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define __CL_ENABLE_EXCEPTIONS</span>
<span class="preprocessor"></span><span class="preprocessor"> #define __NO_STD_VECTOR</span>
<span class="preprocessor"></span><span class="preprocessor"> #define __NO_STD_STRING</span>
<span class="preprocessor"></span> 
<span class="preprocessor"> #if defined(__APPLE__) || defined(__MACOSX)</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;OpenCL/cl.hpp&gt;</span>
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;CL/cl.hpp&gt;</span>
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;cstdio&gt;</span>
<span class="preprocessor"> #include &lt;cstdlib&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>
 
  <span class="keyword">const</span> <span class="keywordtype">char</span> * helloStr  = <span class="stringliteral">&quot;__kernel void &quot;</span>
                           <span class="stringliteral">&quot;hello(void) &quot;</span>
                           <span class="stringliteral">&quot;{ &quot;</span>
                           <span class="stringliteral">&quot;  &quot;</span>
                           <span class="stringliteral">&quot;} &quot;</span>;
 
  <span class="keywordtype">int</span>
  main(<span class="keywordtype">void</span>)
  {
     cl_int err = CL_SUCCESS;
     <span class="keywordflow">try</span> {
       <a class="code" href="classcl_1_1_context.html" title="Context interface for cl_context.">cl::Context</a> context(CL_DEVICE_TYPE_CPU, 0, NULL, NULL, &amp;err); 
 
       <a class="code" href="classcl_1_1vector.html" title="Fixed sized vector implementation that mirroring std::vector functionality.">cl::vector&lt;cl::Device&gt;</a> devices = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;();
 
       cl::Program::Sources source(1,
           std::make_pair(helloStr,strlen(helloStr)));
       <a class="code" href="classcl_1_1_program.html" title="Program interface that implements cl_program.">cl::Program</a> program_ = <a class="code" href="classcl_1_1_program.html" title="Program interface that implements cl_program.">cl::Program</a>(context, source);
       program_.<a class="code" href="classcl_1_1_program.html#a1a93987dc9c26258d528ff2d7cf754c8" title="Build (compile &amp;amp; link) a program executable from the program source or binary...">build</a>(devices);
 
       <a class="code" href="classcl_1_1_kernel.html" title="Kernel interface that implements cl_kernel.">cl::Kernel</a> kernel(program_, <span class="stringliteral">&quot;hello&quot;</span>, &amp;err);
 
       <a class="code" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">cl::CommandQueue</a> queue(context, devices[0], 0, &amp;err);
       <a class="code" href="classcl_1_1_kernel_functor.html" title="Kernel functor interface.">cl::KernelFunctor</a> func = kernel.bind(
          queue,
          <a class="code" href="classcl_1_1_n_d_range.html" title="NDRange interface.">cl::NDRange</a>(4, 4),
          <a class="code" href="classcl_1_1_n_d_range.html" title="NDRange interface.">cl::NDRange</a>(2, 2));
 
       func().wait();
     }
     <span class="keywordflow">catch</span> (cl::Error err) {
        std::cerr 
           &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span>
           &lt;&lt; err.what()
           &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>
           &lt;&lt; err.err()
           &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>
           &lt;&lt; std::endl;
     }
 
    <span class="keywordflow">return</span> EXIT_SUCCESS;
  }
</pre></div><h2><a class="anchor" id="exceptions">
Exceptions</a></h2>
<p>The use of C++ exceptions can provide a structured approach to error handling within large applications. The OpenCL C++ bindings exception feature provides the capability of using C++ exceptions to track and handle errors generated by the underlying OpenCL C API.</p>
<p>It is understood that the use of C++ exceptions is not universal and their use should to optional. Furthermore, if exceptions are not used, then the resulting application must compile and work without exception support. By default C++ exceptions are not enabled and the OpenCL error code is returned, or set, as per the original OpenCL C API.</p>
<p>Exception usage must be explicitly enabled by defining the preprocessor macro <em>__CL_ENABLE_EXCEPTIONS</em>. Once enabled an error, i.e. a value other than <em>CL_SUCCESS</em>, originally reported via a return value will be reported by throwing the exception class <em>Error</em>. By default the <em>what()</em> method of the class <em>Error</em> will return a const pointer to a string naming the particular OpenCL C API called that reported the error, e.g. "clgetDeviceInfo", "clGetPlatformInfo", and so on.</p>
<p>It is possible to override the default behavior for what() by defining the preprocessor macro <em>__CL_USER_OVERRIDE_ERROR_STRINGS</em> and providing string constants for each of the following preprocessor macros:<br/>
 </p>
<div class="fragment"><pre class="fragment">      __GET_DEVICE_INFO_ERR
      __GET_PLATFORM_INFO_ERR
      __GET_DEVICE_IDS_ERR
      __GET_CONTEXT_INFO_ERR
      __GET_EVENT_INFO_ERR
      __GET_EVENT_PROFILE_INFO_ERR
      __GET_MEM_OBJECT_INFO_ERR
      __GET_IMAGE_INFO_ERR
      __GET_SAMPLER_INFO_ERR
      __GET_KERNEL_INFO_ERR
      __GET_KERNEL_WORK_GROUP_INFO_ERR
      __GET_PROGRAM_INFO_ERR
      __GET_PROGRAM_BUILD_INFO_ERR
      __GET_COMMAND_QUEUE_INFO_ERR
      __CREATE_CONTEXT_FROM_TYPE_ERR
      __GET_SUPPORTED_IMAGE_FORMATS_ERR
      __CREATE_BUFFER_ERR
      __CREATE_GL_BUFFER_ERR
      __CREATE_IMAGE2D_ERR
      __CREATE_IMAGE3D_ERR
      __WAIT_FOR_EVENTS_ERR
      __CREATE_KERNEL_ERR
      __SET_KERNEL_ARGS_ERR
      __CREATE_PROGRAM_WITH_SOURCE_ERR
      __CREATE_PROGRAM_WITH_BINARY_ERR
      __BUILD_PROGRAM_ERR
      __CREATE_KERNELS_IN_PROGRAM_ERR
      __CREATE_COMMAND_QUEUE_ERR
      __SET_COMMAND_QUEUE_PROPERTY_ERR
      __ENQUEUE_READ_BUFFER_ERR
      __ENQUEUE_WRITE_BUFFER_ERR
      __ENQEUE_COPY_BUFFER_ERR
      __ENQUEUE_READ_IMAGE_ERR
      __ENQUEUE_WRITE_IMAGE_ERR
      __ENQUEUE_COPY_IMAGE_ERR
      __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR
      __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR
      __ENQUEUE_MAP_BUFFER_ERR
      __ENQUEUE_MAP_IMAGE_ERR
      __ENQUEUE_UNMAP_MEM_OBJECT_ERR
      __ENQUEUE_NDRANGE_KERNEL_ERR
      __ENQUEUE_TASK_ERR
      __ENQUEUE_NATIVE_KERNEL
      __ENQUEUE_MARKER_ERR
      __ENQUEUE_WAIT_FOR_EVENTS_ERR
      __ENQUEUE_BARRIER_ERR
      __UNLOAD_COMPILER_ERR
      __FLUSH_ERR
      __FINISH_ERR
</pre></div><h2><a class="anchor" id="vectorstring">
Replacing STL's vector and string classes</a></h2>
<p>While C++'s Standard Template library provides an excellent resource for quick access to many useful algorithms and containers it is ofen not used due to compatability issues across different toolchains operating systems. In designing the original set of C++ bindings we found it useful to access std::vector and std::string but at the same time realise that it maynot feasible for these to be used within a production system. So like exceptions the developer is given the abilty to not include anything from the STL while using the C++ bindings, and replacements are provided for both std::vector and std::string or the developer has the option to replace their own implementations.</p>
<p>By default, to avoid issues with backward compatibility, both std::vector and std::string are used. Either can be over ridden by defining, for vectors:</p>
<ul>
<li>If __NO_STD_VECTOR is defined and __USE_DEV_VECTOR is not defined, then the vector type:</li>
</ul>
<p>template <a class="el" href="classcl_1_1vector.html" title="Fixed sized vector implementation that mirroring std::vector functionality.">cl::vector</a>&lt; typename T, unsigned int N = __MAX_DEFAULT_VECTOR_SIZE&gt;;</p>
<p>is used instead of std::vector. The space requirments for <a class="el" href="classcl_1_1vector.html" title="Fixed sized vector implementation that mirroring std::vector functionality.">cl::vector</a> are defined statically and default to 10 elements, this default can be over ridden by defining:</p>
<p>define __MAX_DEFAULT_VECTOR_SIZE N</p>
<p>before including <a class="el" href="cl_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 45).">cl.hpp</a>.</p>
<p>For strings:</p>
<ul>
<li>If __NO_STD_STRING is defined and __USE_DEV_STRING is not defined, then the string type:</li>
</ul>
<p>class <a class="el" href="classcl_1_1string.html" title="Simple string class, that provides a limited subset of std::string functionality...">cl::string</a>;</p>
<p>is used instead of std::string. Unlike <a class="el" href="classcl_1_1vector.html" title="Fixed sized vector implementation that mirroring std::vector functionality.">cl::vector</a> the size of a given string is not defined statically but allocated at creation, however, unlike std::string once created its size cannot change.</p>
<p>In the cases where the developer would like to provide their own replacement implementations for either std::vector or std::string, then this can be achived by defining the following.</p>
<p>For vectors the developer must define:</p>
<p>define __USE_DEV_VECTOR</p>
<p>to tell <a class="el" href="cl_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 45).">cl.hpp</a> that std::vector and <a class="el" href="classcl_1_1vector.html" title="Fixed sized vector implementation that mirroring std::vector functionality.">cl::vector</a> should not be used. When __USE_DEV_VECTOR the user must also provide a mapping from their vector template type which must be parametrized with at least a single type argument and all additional arguments must follow this and have defaults. The mapping is given by defining:</p>
<p>define VECTOR_CLASS typeName</p>
<p>Note, that as C++ does not currently support typedef templates the vector type is given solely by its name through a define.</p>
<p>For strings the developer must define:</p>
<p>define __USE_DEV_STRING</p>
<p>to tell <a class="el" href="cl_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 45).">cl.hpp</a> that std::string and <a class="el" href="classcl_1_1string.html" title="Simple string class, that provides a limited subset of std::string functionality...">cl::string</a> should not be used. When __USE_DEV_STRING the user must also provide a mapping from their string class. The mapping is given by defining:</p>
<p>typedef stringType STRING_CLASS; </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 20 09:56:16 2009 for opencl 1.0 c++ bindings by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
